pipeline {
    agent any
    environment {
        // Secrets stored in Jenkins Credentials
        DATABASE_PASSWORD = credentials('DATABASE_PASSWORD')
        CLERK_SECRET_KEY = credentials('CLERK_SECRET_KEY')
        STRIPE_SECRET_KEY = credentials('STRIPE_SECRET_KEY')
        OPENAI_API_KEY = credentials('OPENAI_API_KEY')
        NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = credentials('NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY')
        NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY = credentials('NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY')
        NEXT_PUBLIC_CLERK_SIGN_IN_URL = credentials('NEXT_PUBLIC_CLERK_SIGN_IN_URL')
        NEXT_PUBLIC_CLERK_SIGN_UP_URL = credentials('NEXT_PUBLIC_CLERK_SIGN_UP_URL')
        CLERK_WEBHOOK_SECRET = credentials('CLERK_WEBHOOK_SECRET')

        // Minikube-specific
        KUBECONFIG = "~/.kube/config"
        MINIKUBE_VERSION = 'v1.34.0'
        MINIKUBE_IP = ""
    }

    stages {
        stage('Clone Meta Repository') {
            steps {
                script {
                    // Manually clone the meta repository and run meta git update
                    sh '''
                    git clone https://github.com/NickThompsonDev/meta-tale-compendium.git
                    cd meta-tale-compendium
                    meta git update
                    '''
                }
            }
        }

        stage('Install Minikube if Needed') {
            steps {
                script {
                    sh '''
                    echo "Checking if Minikube is installed..."
                    if ! command -v minikube &> /dev/null; then
                        echo "Minikube not found, installing..."
                        curl -LO https://storage.googleapis.com/minikube/releases/${MINIKUBE_VERSION}/minikube-linux-amd64
                        install minikube-linux-amd64 /usr/local/bin/minikube
                    fi
                    '''
                }
            }
        }

        stage('Start Minikube') {
            steps {
                script {
                    // Start Minikube if it's not running and get its IP
                    sh 'minikube start --driver=docker'
                    MINIKUBE_IP = sh(script: 'minikube ip', returnStdout: true).trim()
                    echo "Minikube IP is ${MINIKUBE_IP}"
                }
            }
        }

        stage('Build Docker Images') {
            parallel {
                stage('Build Webapp') {
                    steps {
                        dir('webapp') {
                            sh """
                            docker build --build-arg DATABASE_PASSWORD=${DATABASE_PASSWORD} \
                                          --build-arg CLERK_SECRET_KEY=${CLERK_SECRET_KEY} \
                                          --build-arg STRIPE_SECRET_KEY=${STRIPE_SECRET_KEY} \
                                          --build-arg OPENAI_API_KEY=${OPENAI_API_KEY} \
                                          --build-arg NEXT_PUBLIC_API_URL=http://${MINIKUBE_IP}/api \
                                          --build-arg NEXT_PUBLIC_WEBAPP_URL=http://${MINIKUBE_IP} \
                                          --build-arg NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=${NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY} \
                                          --build-arg NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY} \
                                          --build-arg NEXT_PUBLIC_CLERK_SIGN_IN_URL=${NEXT_PUBLIC_CLERK_SIGN_IN_URL} \
                                          --build-arg NEXT_PUBLIC_CLERK_SIGN_UP_URL=${NEXT_PUBLIC_CLERK_SIGN_UP_URL} \
                                          -t webapp-tale-compendium:latest -f Dockerfile .
                            """
                        }
                    }
                }

                stage('Build API') {
                    steps {
                        dir('api') {
                            sh """
                            docker build --build-arg DATABASE_PASSWORD=${DATABASE_PASSWORD} \
                                          --build-arg CLERK_SECRET_KEY=${CLERK_SECRET_KEY} \
                                          --build-arg STRIPE_SECRET_KEY=${STRIPE_SECRET_KEY} \
                                          --build-arg OPENAI_API_KEY=${OPENAI_API_KEY} \
                                          --build-arg NEXT_PUBLIC_API_URL=http://${MINIKUBE_IP}/api \
                                          --build-arg NEXT_PUBLIC_WEBAPP_URL=http://${MINIKUBE_IP} \
                                          --build-arg NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=${NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY} \
                                          --build-arg NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY} \
                                          --build-arg NEXT_PUBLIC_CLERK_SIGN_IN_URL=${NEXT_PUBLIC_CLERK_SIGN_IN_URL} \
                                          --build-arg NEXT_PUBLIC_CLERK_SIGN_UP_URL=${NEXT_PUBLIC_CLERK_SIGN_UP_URL} \
                                          -t api-tale-compendium:latest -f Dockerfile .
                            """
                        }
                    }
                }
            }
        }

        stage('Load Docker Images into Minikube') {
            steps {
                script {
                    // Load the Docker images into Minikube
                    sh 'minikube image load webapp-tale-compendium:latest'
                    sh 'minikube image load api-tale-compendium:latest'
                }
            }
        }

        stage('Deploy with Terraform') {
            steps {
                dir('terraform/local') {
                    sh '''
                    terraform init
                    terraform apply -auto-approve -var="minikube_ip=${MINIKUBE_IP}"
                    '''
                }
            }
        }

        stage('Run Tests') {
            steps {
                sh 'echo "Running tests..."'
            }
        }

        stage('Cleanup') {
            steps {
                sh 'docker image prune -f'
            }
        }
    }
}
